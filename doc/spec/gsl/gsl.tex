% =============================================================================
%  $RCSfile: gsl.tex,v $ $Revision: 1.20 $
%  $Date: 2003-10-06 23:02:40 $
%  $Author: koppor $
%
%  Description: Spezifikation der GIANT Scripting Language
%
%  First Author: Steffen Keul
%
% =============================================================================


\documentclass[a4paper,titlepage,11pt,german,twoside]{scrbook}


\makeatletter

%koma uses \chapter*, but we want to use \chapter
%  changed srcbook.cls-commands
\renewcommand\idx@heading{%
  \twocolumn
  \chapter{\indexname}\@mkboth{\indexname}{\indexname}
}

%Nummerierung soll net so eng aneinanderhaengen
\renewcommand*\l@section{\@dottedtocline{1}{1.5em}{3em}}

\makeatother


\usepackage{../../styles/common}

\usepackage{../spec}

\usepackage{ebnf}

\usepackage{verbatim}
\usepackage{shortvrb}

\usepackage{makeidx}
\makeindex

% subsubsections nummerieren
\setcounter{secnumdepth}{3}

\newcommand\version{Version 1.5\xspace}
%\newcommand\version{\today\xspace}

% header
\fancyhead{}
\fancyhead[LE,RO]{\slshape \company}
\fancyhead[LO,RE]{\slshape \leftmark}
\fancyfoot[LE,RO]{\thepage{}}
\fancyfoot[LO,RE]{\version}

\begin{document}

% title page
\thispagestyle{empty}
\hfill
\parbox{5.5cm}
{Universität Stuttgart\\
Studienprojekt A -- IML Browser\\
\company}

\vspace{3cm}

\begin{center}
  \Huge
  \textsf{GIANT Scripting Language \\ Spezifikation}\\
  \vspace{.5cm}
  {\Large\version}\\
  \vspace{3cm}
  \includegraphics[scale=.78]{../../logo}
\end{center}
\newpage

%\input{history}

%==============================================================================
%
% Inhaltsverzeichnis
%
\setcounter{tocdepth}{1}
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Beginn des Texts
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{GIANT Scripting Language}


\MakeShortVerb{\°}


%%%% Non-terminals

%%%% Tokens
\token{\tokbegincomment}{//}
\token{\tokbeginsequence}{[}
\token{\tokclosebracket}{)}
\token{\tokcurlyclose}{\}}
\token{\tokcurlyopen}{\{}
\token{\tokcomma}{,}
\token{\tokdot}{.}
\token{\tokendsequence}{]}
\token{\tokopenbracket}{(}
\token{\toknull}{null}
\token{\tokfalse}{false}
\token{\tokplus}{+}
\token{\tokselection}{selection}
\token{\toksemicolon}{;}
\token{\toksubgraph}{subgraph}
\token{\toktick}{'}
\token{\toktrue}{true}
\token{\tokquote}{''}
\token{\tokunderscore}{\_}

\nonterminal{\nidentifier}{identifier}
\nonterminal{\nchar}{char}
\nonterminal{\ndigit}{digit}
\nonterminal{\nliteral}{literal}
\nonterminal{\nbooleanliteral}{boolean\_literal}
\nonterminal{\nintliteral}{int\_literal}
\nonterminal{\nstringliteral}{string\_literal}
\nonterminal{\nstringchar}{direct\_char}
\nonterminal{\neverychar}{every\_char}
\nonterminal{\nnullliteral}{null\_literal}
\nonterminal{\nexpression}{expression}
\nonterminal{\ninspection}{inspection}
\nonterminal{\nvisiblevar}{visible\_var}
\nonterminal{\nglobalvar}{global\_var}
\nonterminal{\nsubgraph}{subgraph}
\nonterminal{\nselection}{selection}
\nonterminal{\nreference}{reference}
\nonterminal{\nvisibleref}{visible\_ref}
\nonterminal{\nvarcreation}{var\_creation}
\nonterminal{\nglobalref}{global\_ref}
\nonterminal{\nscriptdecl}{script\_decl}
\nonterminal{\nlist}{list}
\nonterminal{\nsequence}{sequence}
\nonterminal{\nscriptactivation}{script\_activation}

\newcommand{\bottomenv}{\ensuremath{First}\xspace}
\newcommand{\newenv}{\ensuremath{A_{neu}}\xspace}
\newcommand{\oldenv}{\ensuremath{A_{alt}}\xspace}
\newcommand{\startenv}{\ensuremath{A_{start}}\xspace}



In diesem Dokument wird die GIANT Scripting Language (GSL) sowie der
Interpreter zur Ausführung von GSL Scripts spezifiziert.
GSL ist eine Skriptsprache für das Software-System GIANT. Mit Hilfe von
GSL können Anfragen an die IML-Bibliothek gestellt werden und auf den
Resultaten Aktionen ausgeführt werden.

Hier wird zunächst die Struktur von IML-Graphen aus der Sicht
von GIANT beschrieben und danach die Syntax und Sematik von GSL definiert.
Schließlich folgt die vollständige Beschreibung der angebotenen
Sprachumgebung.

\section{IML-Graphen}

Der Kunde stellt die Reflektion zur Verfügung. GIANT verwendet diese
Bibliothek, um auf IML-Graph Dateien zuzugreifen.

\subsection{IML-Datenbasis}
\index{IML-Graph Datei!Inhalt}

In jeder IML-Graph Datei sind IML-Daten enthalten. Diese
bestehen aus
\begin{enumerate}
\item IML-Knoten
\item Attributen von IML-Knoten
\item nichts sonst.
\end{enumerate}

Es gibt in jeder IML-Graph Datei genau einen besonderen IML-Knoten,
der Wurzelknoten genannt wird.

\subsubsection{Attribute von IML-Knoten}

Jeder IML-Knoten hat einen Typ. Für jeden Typ von IML-Knoten existiert ein
String, der den Typ eindeutig identifiziert.

Jeder IML-Knoten verfügt über eine endliche Folge von Attributen.
Diese Folge definiert eine endliche Anzahl einzelner Attribute,
die der IML-Knoten besitzt, sowie eine Reihenfolge dieser Attribute.
Weder die Folge von Attributen noch die in der Folge enthaltenen
Attribute eines IML-Knoten können sich während der Laufzeit von
GIANT verändern.

Jedes Attribut besitzt einen Attribut-Namen. Kein IML-Knoten besitzt
zwei verschiedene Attribute, die einen gleichen Namen besitzen.

Einige Attribute sind Verweise. Sie verweisen auf höchstens einen
IML-Knoten. Es werden unterschieden:
\begin{description}
\item[Verweise] Verweise, die auf genau einen IML-Knoten verweisen.
\item[Nullverweise] Verweise, die auf einen besonderen Wert verweisen,
           der kein IML-Knoten ist. Ein Nullverweis ist kein Verweis.
\end{description}

Jedes Attribut eines IML-Knoten gehört genau einer der folgenden Klassen an:
\begin{description}
\item[Einfache Attribute]: Haben einen bestimmten Wert.
           Mögliche Typen dieses Werts sind:
           \begin{enumerate}
           \item Source Location
                 \begin{enumerate}
                 \item Zeilennummer (Natural)
                 \item Spaltennummer (Natural)
                 \item Filename (String)
                 \item Pfadname (String)
                 \end{enumerate}
           \item Boolean
           \item Natural
           \item String
           \item Folge von Strings
           \end{enumerate}
\item[Verweis-Attribut] Ein Verweis
\item[Nullverweis-Attribut] Ein Nullverweis. Ein Nullverweis-Attribut ist
kein Verweis-Attribut.
\item[Verweisfolgen-Attribut] Eine endliche Folge von Verweisen
\item[Verweismengen-Attribut] Eine endliche Menge von Verweisen
\end{description}



\subsection{IML-Graphen}
\hyphenation{kanten-annotierter}

Die IML-Daten jeder IML-Graph Datei definieren einen zugehörigen IML-Graph.
Sprechweise: Die IML-Daten liegen dem IML-Graph zugrunde.
Ein IML-Graph ist ein gerichteter knoten- und kantenannotierter Graph mit
Schlingen und Mehrfachkanten. Er ist definiert durch die folgende
Vorschrift:

\begin{enumerate}
\item
Ein IML-Graph besitzt als Knotenmenge die Menge aller IML-Knoten der
zugrunde liegenden IML-Daten. Der IML-Graph besitzt keine
weiteren Knoten.
\item
Annotationen eines IML-Knoten sind alle Attribute des IML-Knoten.
\item
\label{edge_spec}
Eine Kante im IML-Graph heißt IML-Kante. Eine IML-Kante $e$ von einem
IML-Knoten $v$ zu einem IML-Knoten $w$ des selben IML-Graph existiert
genau dann, wenn eine der folgenden Bedingungen erfüllt ist:
   \begin{enumerate}
   \item $v$ besitzt ein Verweis-Attribut, das auf $w$ verweist.
         \begin{enumerate}
         \item Dann besitzt $e$ als Annotation den Attribut-Namen $s$ des
         Verweis-Attributs.
         \item Das Paar $(type (v), s)$ heißt Typ der IML-Kante $e$
         \end{enumerate}
   \item $v$ besitzt ein Verweisfolgen-Attribut $f$. Ein Verweis
         aus $f$ verweist auf $w$.
         \begin{enumerate}
         \item dann besitzt $e$ als Annotation den Attribut-Namen $s$ von
         $f$ sowie
         die Nummer innerhalb der Folge $f$ des Verweises auf $w$.
         \item Das Paar $(type (v), s)$ heißt Typ der IML-Kante $e$.
         \end{enumerate}
   \item $v$ besitzt ein Verweismengen-Attribut $m$. Ein Verweis
         aus $m$ verweist auf $w$.
         \begin{enumerate}
         \item dann besitzt $e$ als Annotation den Attribut-Namen $s$ von $m$.
         \item Das Paar $(type (v), s)$ heißt Typ der IML-Kante $e$.
         \end{enumerate}
   \end{enumerate}
\item Falls eine IML-Kante $e$ existiert, so hat $e$ keine Annotationen,
außer den in Punkt \ref{edge_spec} genannten.
\end{enumerate}



\section{GSL Interpreter}

Ein GSL Interpreter ist ein System, das GSL Ausdrücke auswertet, gemäß
der Sprachdefinition in Kapitel \ref{gsl_spec}. Jeder GSL
Interpreter muss die vordefinierte Sprachumgebung nach Kapitel
\ref{predef_env} unterstützen.

\subsection{Start einer Auswertung}
\label{interpreter_start}

Beim Start des GSL Interpreters erzeugt dieser zunächst die erste
Aktivierungsumgebung \bottomenv. Danach ist der GSL Interpreter bereit
und ihm kann ein beliebiger GSL Ausdruck
zur Auswertung übergeben werden. In GIANT kann dies geschehen, indem der
Ausdruck als Kommandozeilenparameter angegeben wird oder indem ein Ausdruck
in das dafür vorgesehene Anzeigefenster eingegeben wird.

Dieser Ausdruck kann gespeicherte GSL Scripts aufrufen und mit GIANT
kommunizieren.

\subsection{Kontext des Interpreters}

Der GSL Interpreter kann im Kontext eines GIANT-Anzeigefensters ausgeführt
werden. Ist dies der Fall, so können die ausgewerteten GSL Ausdrücke
Aktionen in diesem Anzeigefenster durchführen.

Wird der GSL Interpreter nicht im Kontext eines Anzeigefensters ausgeführt,
so können die GSL Ausdrücke keine Aktion in einem Anzeigefenster
auslösen.

Ein GSL Script kann den GSL Interpreter anweisen in den Kontext eines
bestimmten Anzeigefensters zu wechseln.

\subsection{Verhalten im Fehlerfall}

\subsubsection{Syntaxfehler}
\label{syntax_error}

Der GSL Interpreter muss einen Ausdruck zurückweisen, falls eine
Forderung der Sprachdefinition durch diesen Ausdruck verletzt
wird. In diesem Fall muss der Interpreter dem Benutzer eine Fehlermeldung
anzeigen.
Andernfalls startet der GSL Interpreter die Auswertung des GSL Ausdrucks.

\subsubsection{Laufzeitfehler}
\label{run_time_error}

Der GSL Interpreter muss die Ausführung sofort
stoppen, sobald ein Laufzeitfehler auftritt. Dies kann nur dann
geschehen und muss jedes Mal geschehen,
wenn die Semantikdefinition es vorschreibt. Der GSL Interpreter
darf die Ausführung bereits nach einem früheren Ausführungsschritt abbrechen,
wenn sichergestellt ist, dass nach einem späteren Ausführungsschritt
ein Laufzeitfehler auftreten wird.
Der GSL Interpreter zeigt dem Benutzer eine Fehlermeldung an.

Der GSL Interpreter muss nach einem Fehler entweder alle seit Beginn
der Ausführung bereits ausgeführten Aktionen rückgängig machen, oder er
muss dem Benutzer anzeigen, welche Aktionen bereits ausgeführt wurden,
bevor der Fehler passierte.

\section{Konzepte}

Der Entwurf von GSL legt das größte Gewicht auf eine einfache Erweiterbarkeit
der Ausdrucksmächtigkeit der Sprache. Durch Hinzufügen von zusätzlichen
vordefinierten Scripts können der Sprache neue Fähigkeiten hinzugefügt werden
ohne dabei Änderungen an der Syntax vornehmen zu müssen. Diesem wichtigsten
Ziel wurden Aspekte wie eine intuitiv erfassbare Syntax untergeordnet.

\subsection{Werte und Typen}
\label{types}

\newcommand\typename[2]{\newcommand{#1}{{\sf #2}\xspace}}
\typename{\tnodeid}{Node\_Id}
\typename{\tedgeid}{Edge\_Id}
\typename{\tnodeset}{Node\_Set}
\typename{\tedgeset}{Edge\_Set}
\typename{\tobjectset}{Object\_Set}
\typename{\tsloc}{Source\_Location}
\typename{\tstring}{String}
\typename{\tboolean}{Boolean}
\typename{\tnatural}{Natural}
\typename{\tlist}{List}
\typename{\tvarreference}{Var\_Reference}
\typename{\tscriptreference}{Script\_Reference}

\subsubsection{Vordefinierte Typen}

GSL verarbeitet Werte verschiedener Typen. Werte können das Ergebnis der
Auswertung von Ausdrücken sein. Werte können in Objekten gespeichert werden.

Nachfolgend wird eine Liste aller
Typen sowie der Werte angegeben, die ein Ausdruck des entsprechenden Typs
annehmen kann:
\begin{description}
\item[\tnodeid] Verweis auf einen einzelnen Knoten.
\item[\tedgeid] Verweis auf eine einzelne Kante.
\item[\tnodeset] Endliche Menge von Werten des Typs \tnodeid.
\item[\tedgeset] Endliche Menge von Werten des Typs \tedgeid.
\item[\tstring] Endliche Folge von Zeichen.
\item[\tboolean] Der Wahrheitswerte \tokfalse und \toktrue
\item[\tnatural] Natürliche Zahl, innerhalb eines bestimmten Bereichs, der
von der Reflektion vorgegeben wird.
\item[\tlist] Endliche Folge von Werten. Jeder dieser Werte ist ein Wert
eines beliebigen Typs aus dieser Aufzählung oder \toknull.
\item[\tvarreference] Zugriffspfad auf ein Objekt.
\item[\tscriptreference] Aktivierungsinformation für ein bestimmtes Script.
\end{description}

Zusätzlich gibt es noch einen besonderen Typ, der keinen Namen besitzt.
Dieser anonyme Typ umfasst genau einen Wert, nämlich den Wert \toknull.

Alle diese Typen decken alle Typen der IML-Reflection ab. Falls
zur IML-Reflection neue Typen hinzugefügt werden, so werden diese
ebenfalls in der GSL eingeführt.

\subsubsection{Zusammengesetzte Typen}

Werte zusammengesetzter Typen sind zusammengesetzt aus mehreren Werten
der vordefinierten Typen. In dieser Spezifikation wird im Folgenden nicht
mehr zwischen vordefinierten und zusammengesetzten Typen unterschieden.

\begin{description}
\item[\tobjectset] Wert des vordefinierten Typs \tlist mit genau zwei
Einträgen $N$ und $E$. Dabei muss $N$ ein Wert des Typs \tnodeset und $E$
ein Wert des Typs \tedgeset sein.
\item[\tsloc] Wert des vordefinierten Typs \tlist mit genau vier Einträgen
$L$, $S$, $F$, $P$. Dabei muss gelten:
 \begin{enumerate}
 \item $L$ ist vom Typ \tnatural (\gq{Zeilennummer}).
 \item $S$ ist vom Typ \tnatural (\gq{Spaltennummer}).
 \item $F$ ist vom Typ \tstring (\gq{Filename}).
 \item $P$ ist vom Typ \tstring (\gq{Pfadname}).
 \end{enumerate}
\end{description}

\subsection{Ausdrücke}

Die Ausführung von GSL geschieht ausschließlich durch das Auswerten von
Ausdrücken. Die Auswertung eines Ausdrucks hat als Ergebnis stets genau
einen bestimmten Wert und kann Nebeneffekte haben. Nebeneffekte sind
Veränderungen an den Werten von Objekten oder die Durchführung von Aktionen.

Der Typ eines Ergebnisses steht im Allgemeinen erst fest, nachdem ein Ausdruck
ausgewertet wurde. Die Auswertung eines Ausdrucks kann fehlschlagen, falls
ein Laufzeitfehler auftritt. In diesem Fall stoppt die Auswertung sofort.

\subsection{Variablen und Objekte}
\label{variables}

Um während der Auswertung von Ausdrücken bestimmte Werte zur späteren
Wiederverwendung zu speichern werden \emph{Objekte} verwendet. Der Zugriff
auf ein Objekt erfolgt durch eine Variable oder einen Zugriffspfad.

In \emph{Aktivierungsumgebungen} werden Variablen an Objekte gebunden.

\label{variable_inspection}
Variablen können \emph{inspiziert} werden. Das Ergebnis einer
Variableninspektion ist der Wert des Objekts, an das die Variable gebunden
ist.

\label{variable_reference}
Eine \emph{Referenz} einer Variable kann genommen werden.
Diese Referenz ist ein
Zugriffspfad auf das Objekt an das die Variable gebunden ist. Der
Zugriffspfad wird benötigt, um den Wert des Objekts zu verändern.

Eine Variable kann entweder sichtbar oder unsichtbar sein. Siehe hierzu
Kapitel \ref{visibility}.

Jedes Objekt kann einen Wert $w_1$ jedes beliebigen Typs $t_1$ aus
\ref{types} annehmen. Durch eine weitere Zuweisung an das Objekt kann
das Objekt einen anderen Wert $w_2$ des Typs $t_2$ annehmen. Dabei dürfen
die beiden Werte aus verschiedenen Typen sein (dh.\ $t_1 \neq t_2$ ist
zulässig).

\subsection{Aktivierungsumgebungen}

\subsubsection{Standard-Aktivierungsumgebung}

\label{bottom_env}
Eine Aktivierungsumgebung bindet Variablen an Objekte. Beim Start des GSL
Interpreters existiert eine erste Aktivierungsumgebung \bottomenv.

In \bottomenv existiert für jeden zulässigen Namen °<Name>° eines
IML-Teilgraphen in GIANT eine Variable \gq{\toksubgraph\tokdot°<Name>°}.
(Es gibt also aufzählbar unendlich viele solche Variablen.)
Jede dieser Variablen ist an den IML-Teilgraphen mit dem entsprechenden
Namen °<Name>° gebunden, sofern dieser IML-Teilgraph existiert.
Existiert der IML-Teilgraph nicht, so ist die Variable an ein besonderes
Objekt gebunden, das den Wert \toknull hat.

Falls der GSL Interpreter im Kontext eines Anzeigefensters $W$ ausgeführt wird,
dann existiert in \bottomenv für jeden zulässigen Namen °<Name>° einer
Selektion im Fenster $W$ eine Variable \gq{\tokselection\tokdot°<Name>°}.
(Es gibt also aufzählbar unendlich viele solche Variablen.)
Jede dieser Variablen ist an die Selektion mit dem entsprechenden
Namen °<Name>° gebunden, sofern diese Selektion existiert.
Existiert die Selektion nicht, so ist die Variable an ein besonderes
Objekt gebunden, das den Wert \toknull hat. Wird der GSL Interpreter nicht
im Kontext einen Anzeigefensters ausgeführt, so existiert keine dieser
Variablen.

Die erste Aktivierungsumgebung \bottomenv ist anfangs \emph{aktuell}.

\subsubsection{Vererbung von Aktivierungsumgebungen}
\label{current_env}

Wann immer der GSL Interpreter die Auswertung eines benutzerdefinierten
GSL Ausdrucks startet (siehe \ref{interpreter_start}), wird eine neue
Aktivierungsumgebung \startenv erzeugt. \startenv \emph{beerbt} dabei
\bottomenv. \startenv wird aktuell bevor die Auswertung des benutzerdefinierten
Ausdrucks beginnt. Nachdem die Auswertung abgeschlossen ist, wird \startenv
zerstört und \bottomenv wird wieder aktuell.

Falls während der Auswertung eines Ausdrucks die Aktivierung eines Scripts
erfolgt, so wird eine neue Aktivierungsumgebung für die Auswertung
dieses Scripts erzeugt. Diese neue Aktivierungsumgebung \newenv beerbt eine
bestimmte Aktivierungsumgebung \oldenv, die durch die Aktivierungsinformation
bestimmt wird (siehe \ref{script_activation}). \newenv wird aktuell.
Nachdem die Auswertung des Script beendet ist wird \newenv zerstört und \oldenv
wird wieder aktuell.

Während ein Script ausgewertet wird, können weitere Scripts aktiviert werden.
Deshalb können mehrere Aktivierungsumgebungen gleichzeitig existieren. Auf
diesen Aktivierungsumgebungen existiert eine Vererbungsbeziehung die durch
eine partielle Ordnung beschrieben $\le$ werden kann:
\begin{enumerate}
\item Für zwei Aktivierungsumgebungen $A_1, A_2$ gilt: $($ falls $A_2$ beerbt
$A_1 ) \Rightarrow A_1 \le A_2$
\item Für jede Aktivierungsumgebung $A$ gilt: $A \le A$
\item Für zwei Aktivierungsumgebung $A_1, A_2$ gilt:
$A_1 \le A_2 \wedge A_2 \le A_1 \Rightarrow A_1 = A_2$
\item Für drei Aktivierungsumgebungen $A_1, A_2, A_3$ gilt:
$A_1 \le A_2 \wedge A_2 \le A_3 \Rightarrow A_1 \le A_3$
\end{enumerate}

\textbf{Anmerkung} Weil nach Start des GSL Interpreters eine erste
Aktivierungsumgebung \bottomenv erzeugt wird, aufgrund der beschriebenen
Vererbung und aufgrund der Transitivität
von $\le$ gilt für jede Aktivierungsumgebung $A$:
$\bottomenv \le A$.

\subsubsection{Sichtbarkeit}
\label{visibility}

Annahme: Die Aktivierungsumgebung \newenv beerbt die Aktivierungsumgebung
\oldenv. Dann bindet \newenv mindestens alle Variablen, die
auch \oldenv bindet. In \newenv können zusätzlich
\begin{enumerate}
\item weitere Variablen gebunden werden, die in \oldenv nicht gebunden
sind.
\item Variablen, die in \oldenv gebunden sind, an andere Objekte
gebunden werden (überladen).
\end{enumerate}

Eine Variable $v$ heißt \emph{lokal} in \newenv, falls sie eine der
folgenden Bedingungen erfüllt:
\begin{enumerate}
\item Es existiert keine Aktivierungsumgebung \oldenv, die von \newenv
beerbt wird oder
\item \newenv beerbt \oldenv. $v$ ist in \oldenv an ein Objekt $o_1$
gebunden ist und $v$ ist in \newenv an ein Objekt $o_2$ mit $o_1 \neq o_2$
gebunden oder
\item \newenv beerbt \oldenv. $v$ ist in \oldenv nicht gebunden, und
$v$ ist in \newenv gebunden an irgend ein Objekt.
\end{enumerate}

Jede Variable, die in \newenv an irgend ein Objekt gebunden ist, heißt
\emph{sichtbar} in \newenv.

Jede Variable, die in \newenv sichtbar ist, aber nicht lokal in \newenv ist,
heißt \emph{global} in \newenv.

\textbf{Anmerkung} In einer Aktivierungsumgebung $A_1$ sind alle Variablen
sichtbar, die in irgend einer Aktivierungsumgebung $A_2$ mit $A_2 \le A_1$
sichtbar sind.

\paragraph{Beispiel}

\verbatiminput{visibility.gsl}

\subsection{Aktivierung von Scripts}

Ein Script ist ein Paar aus
\begin{description}
\item[Parameterliste] einer (möglicherweise leeren) Liste von Ausdrücken,
deren Ergebnis Zugriffspfade auf Objekte sein müssen.
\item[Rumpf] einem Ausdruck.
\end{description}

\paragraph{Beispiel einer Script-Deklaration}

\verbatiminput{scriptdecl.gsl}

\subsubsection{Ablauf der Aktivierung}
\label{activation_process}

Ein Script $S$ kann \emph{aktiviert} werden. Wenn $S$ aktiviert wird, dann
wird eine neue Aktivierungsumgebung \newenv erzeugt. Es werden die Argumente
des Aufrufs an die Parameter von $S$ übergeben. Der Rumpf von $S$ wird
ausgewertet. Das Ergebnis der Auswertung von $S$ ist das Ergebnis der
Auswertung des Rumpfs von $S$. Für die genaue Beschreibung siehe
\ref{script_activation}.

\subsubsection{Vorraussetzung}
\label{activation_preconds}

Ein Script $S$ wird aktiviert durch Auswertung eines Ausdrucks, der als
Ergebnis einen
Wert des Typs \tscriptreference hat. Dieser Wert wird als
Aktivierungsinformation bezeichet.

Die Aktivierungsinformation bestimmt
\begin{enumerate}
\item Welches Script ausgeführt wird (Quelltext-Position von $S$ oder eine
gleichwertige Darstellung).
\item Welche Aktivierungsumgebung beerbt wird, wenn die Aktivierung
stattfindet. \label{allowed_environments}
\end{enumerate}

Vor der Aktivierung des Scripts $S$ wird eine neue Aktivierungsumgebung
\newenv erzeugt und danach aktuell.
Das zu aktivierende Skript $S$ kann eine in \newenv globale Variable
$v$ inspizieren, oder die Referenz von $v$ nehmen.
Es soll sichergestellt werden, dass die neue Aktivierungsumgebung \newenv nur
solche Aktivierungsumgebungen \oldenv beerben kann, so dass die Variable $v$
in \oldenv genau die Bedeutung hat, die der Autor von $S$ erwartet.
Dies stellt Punkt \ref{allowed_environments} der vorangehenden Aufzählung
sicher. \oldenv ist \emph{nicht} zwangsläufig die vor der Aktivierung von
$S$ aktuelle Aktivierungsumgebung. \oldenv ist diejenige Aktivierungsumgebung,
die zum Zeitpunkt der Auswertung der Script-Deklaration von $S$
(siehe \ref{script_decl}) aktuell war.

\paragraph{Beispiel zur Scriptaktivierung}

\verbatiminput{activation.gsl}

\subsubsection{Parameterübergabe}
\label{parameter_passing}

In dem Ausdruck dessen Auswertung die Aktivierung eines Scripts veranlasst
wird eine Liste von Argumenten $L_e = (e_1, ..., e_n)$ angegeben mit
$n \in {0, 1, 2, ...}$ und $\forall 1 \le i \le n: (e_i$ ist ein Ausdruck$)$.
Bevor die Aktivierung beginnt, wird
$L_e$ ausgewertet und hat als Ergebnis den Wert $L_a = (a_1, ..., a_n)$.

Nachdem die Aktivierung begonnen hat, wird
die Parameterliste ausgewertet (siehe Abschnitt \ref{script_activation}).
Das Ergebnis dieser Auswertung muss ein Wert $L_p$ vom Typ
\tlist sein. Es muss gelten $L_p = (p_1, ..., p_n)$ mit
$\forall 1 \le i \le n: ( p_i$ ist ein Zugriffspfad auf ein Objekt$)$.
Andernfalls führt die Auswertung zu einem Laufzeitfehler.

Dann wird für alle $i$ jedem Objekt, das durch den Zugriffspfad $p_i$ erreicht
wird, der Wert $a_i$ zugewiesen. In GSL formuliert wird der Ausdruck
°(set (°$p_1$°, °$a_1$°), ..., set (°$p_n$°, °$a_n$°))°
ausgewertet und sein Ergebnis verworfen (Hinweis: Dieser Ausdruck ist kein
korrekter GSL-Ausdruck, sondern dient nur der intuitiven Erläuterung).

Danach ist die Parameterübergabe abgeschlossen und der Rumpf des Scripts wird
ausgewertet.

\textbf{Richtlinie} Für die Parameter $p_i$ sollte jeweils eine
neue lokale Variable erzeugt werden, z.B. durch \gq{°+name°}.

\paragraph{Beispiel zur Parameterübergabe}

\verbatiminput{parameters.gsl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax und Semantik}
\label{gsl_spec}

\subsection{Notation}

Die Syntax von GSL wird als kontextfreie Grammatik beschrieben.
\begin{enumerate}
\item Nichtterminale werden in einer serifenlosen Schrift dargestellt
(z.B. \nidentifier).
\item Terminalsymbole werden fett gedruckt (z.B. \toknull).
\item Eine Regel wird geschrieben als 
\begin{EBNF}
\item[{\sl linke Seite}] {\sl rechte Seite}
\end{EBNF}
wobei auf der linken Seite genau ein Nichtterminal steht, das bei Anwendung
der Regel durch die rechte Seite ersetzt werden darf.
\item Alternativen werden angegeben als
{\sl erste Möglichkeit} | {\sl zweite Möglichkeit}
\item Die Klammern $\langle$ {\sl Inhalt} $\rangle$ werden verwendet um ihren
Inhalt zusammenzufassen.
\item Ein Teil kann gar nicht, einmal oder beliebig oft expandiert werden,
wenn er von einem * gefolgt wird.
\item Ein Teil ist optional, falls er von einem $?$ gefolgt wird.
\end{enumerate}

Die Beschreibung der Bedeutung einer Regel erfolgt in einer Aufzählung, die
unter der Regel steht. In der Beschreibung werden
die Nichtterminale aus der rechten Seite der Regel als Platzhalter
für ihre Ableitung (also den Terminalstring zu dem sie im Programmtext
erweitert sind) verwendet.

\subsection{Schlüsselwörter und lexikalische Elemente}
\label{tokens}

\begin{tabular}{l l l l}
\tokopenbracket & \tokclosebracket & \tokcurlyopen  & \tokcurlyclose \\
\tokbeginsequence & \tokendsequence & \tokcomma & \tokdot \\
\toksemicolon & \toktick & \tokplus & \tokunderscore \\

\tokselection & \toksubgraph & \tokbegincomment & \tokquote \\
\tokfalse & \toktrue & \toknull & °\° \\
\end{tabular}

Es wird zwischen Groß- und Kleinschreibung unterschieden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kommentare}

In GSL-Dateien können Kommentare eingegeben werden, die auf die Semantik
des Programms keinen Einfluss haben. Ein Kommentar beginnt mit \tokbegincomment
und endet am Ende der Zeile. Alle Zeichen dazwischen gehören zu dem Kommentar.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{White Space}

Leerzeichen, Tabulatoren, Zeilenumbrüche und Kommentare werden als Trennzeichen
verwendet. Zwischen Schlüsselwörtern, den in \ref{tokens} aufgeführten
Zeichen und \nidentifier dürfen beliebig viele Trennzeichen geschrieben werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Identifier}

\begin{EBNF}
\item[\nidentifier] \nchar $\langle$ \nchar | \ndigit | \tokunderscore
 $\rangle$*
\end{EBNF}

Dabei steht \nchar für eines der Zeichen a-z, A-Z. \ndigit steht für eine
der Ziffern 0-9.

\begin{enumerate}
\item Der Text eines \nidentifier darf nicht gleich sein wie ein
GSL-Schlüsselwort (siehe \ref{tokens}).
\item Die Groß- und Kleinschreibung eines \nidentifier wird
unterschieden (Beispiel: \gq{Name} $\neq$ \gq{name}).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Literale}

\begin{EBNF}
\item[\nliteral] \nbooleanliteral | \nintliteral | \nstringliteral
                 | \nnullliteral
\end{EBNF}

\begin{enumerate}
\item Ein \nliteral hat einen bestimmten Typ, und als Ergebnis einen Wert
dieses Typs.
\item Typ und Wert eines \nliteral stehen bereits zum Übersetzungszeitpunkt
fest. (siehe entsprechendes Nichtterminal der rechten Seite).
\end{enumerate}

\subsubsection{Boolean-Literal}

\begin{EBNF}
\item[\nbooleanliteral] \tokfalse | \toktrue
\end{EBNF}

\begin{enumerate}
\item Ein \nbooleanliteral ist vom Typ \tboolean.
\item Der Wert ist \tokfalse, falls die rechte Seite \tokfalse gewählt wurde.
\item Der Wert ist \toktrue, falls die rechte Seite \toktrue gewählt wurde.
\end{enumerate}

\subsubsection{Integer-Literal}

\begin{EBNF}
\item[\nintliteral] \ndigit \ndigit{}*
\end{EBNF}

\begin{enumerate}
\item Ein \nintliteral ist vom Typ \tnatural.
\item Der Wert ist die Interpretation des Texts im Zehnersystem.
\end{enumerate}

\subsubsection{String-Literal}

\begin{EBNF}
\item[\nstringliteral] \tokquote $\langle$ °\°\tokquote |
                       °\\° | °\°n | °\°t |
                       \nstringchar $\rangle$*
                       \tokquote
\end{EBNF}

Dabei steht \nstringchar für jedes Zeichen des (implementationsabhängigen)
Zeichensatzes außer den Zeichen °\° und \tokquote.

\begin{enumerate}
\item Ein \nstringliteral ist vom Typ \tstring.
\item Der Wert ist die ersetzte Folge von Zeichen zwischen den \tokquote.
\item Die Zeichenfolge °\°\tokquote wird dabei ersetzt durch
ein einfaches \tokquote.
\item °\\° wird ersetzt durch das Zeichen °\°.
\item °\°n wird ersetzt durch das Zeichen Zeilenumbruch.
\item °\°t wird ersetzt durch ein Tabulatorzeichen.
\end{enumerate}

\subsubsection{Null-Literal}

\begin{EBNF}
\item[\nnullliteral] \toknull
\end{EBNF}

\begin{enumerate}
\item Der Typ eines \nnullliteral ist der anonyme Typ. Dieser Typ hat keinen
Namen.
\item Der Wert ist \toknull.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ausdrücke}

\begin{EBNF}
\item[\nexpression] \nliteral | \ninspection | \nreference | \nscriptdecl
                    | \nlist | \nsequence | \nscriptactivation
\end{EBNF}

\begin{enumerate}
\item \nexpression können zur Laufzeit \emph{ausgewertet} werden.
\item Während der Auswertung kann ein Laufzeitfehler auftreten. In diesem
Fall stoppt die Auswertung (siehe \ref{run_time_error}).
\item Um eine \nexpression auszuwerten wird die entsprechende rechte Seite
ausgewertet. Näheres dazu ist der Beschreibung der rechten Seite zu entnehmen.
\item Die Auswertung einer \nexpression kann \emph{Seiteneffekte} haben.
Die Seiteneffekte hängen von der gewählten rechten Seite ab.
\item Die Auswertung einer \nexpression hat ein Ergebnis, falls kein
Laufzeitfehler aufgetreten ist. Das Ergebnis ist stets ein Wert eines
bestimmten Typs. Das Ergebnis ist identisch mit dem Ergebnis der
Auswertung der rechten Seite der gewählten Regel. Siehe Beschreibung der
rechten Seiten.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Inspektion}

\begin{EBNF}
\item[\ninspection] \nvisiblevar | \nglobalvar
\end{EBNF}

\begin{enumerate}
\item Eine \ninspection inspiziert den Wert des Objekts, das an die
zu inspizierende Variable gebunden ist (siehe \ref{variable_inspection}).
\item Die verschiedenen rechten Seiten werden verwendet um zwischen
Variablen zu unterscheiden, die an GSL-Objekte gebunden sind, und
Variablen, die an IML-Teilgraphen oder Selektionen in GIANT gebunden sind.
\item Das Ergebnis der \ninspection ist identisch mit dem Ergebnis der
gewählten rechten Seite.
\end{enumerate}

\begin{EBNF}
\item[\nvisiblevar] \nidentifier
\end{EBNF}

\begin{enumerate}
\item Inspiziert das Objekt, das in der aktuellen Aktivierungsumgebung
an die sichtbare Variable mit Name
\nidentifier gebunden ist (siehe \ref{visibility}).
\item Falls keine sichtbare Variable dieses Namens existiert, dann ist
die Auswertung ein Laufzeitfehler. Andernfalls ist die Inspektion
erfolgreich.
\item Falls die Inspektion erfolgreich ist, so ist das Ergebnis der Wert
des Objekts an das die Variable gebunden ist.
\end{enumerate}

\label{global_inspection}
\begin{EBNF}
\item[\nglobalvar] $\langle$ \toksubgraph | \tokselection
                   $\rangle$ \tokdot \nidentifier
\end{EBNF}

\begin{enumerate}
\item Falls \toksubgraph angegeben ist:
  \begin{enumerate}
  \item Diese Inspektion ist eine Schnittstelle zu GIANT.
  \item Falls in GIANT ein IML-Teilgraph $T$ mit Namen \nidentifier existiert,
  dann ist das Ergebnis dieser Inspektion ein Wert $M$ vom zusammengesetzten
  Typ \tobjectset. $M$ enthält alle Graph-Knoten aus $T$ und alle
  Graph-Kanten aus $T$ und nichts sonst.
  \item Falls in GIANT $T$ nicht existiert, so ist das Ergebnis dieser
  Inspektion der Wert \toknull.
  \item Formal erfolgt eine Inspektion der Variable mit Namen
  \toksubgraph.\nidentifier. Diese Variable ist stets in der
  Aktivierungsumgebung \bottomenv gebunden und deshalb stets sichtbar.
  \end{enumerate}
\item Falls \tokselection angegeben ist:
  \begin{enumerate}
  \item Diese Inspektion ist eine Schnittstelle zu GIANT.
  \item Falls der GSL Interpreter im Kontext eines Anzeigefensters ausgeführt
  wird und in diesem Anzeigefenster eine Selektion $S$ mit Namen \nidentifier
  existiert, dann ist das Ergebnis dieser Inspektion ein Wert $M$ vom Typ
  \tobjectset.
  $M$ enthält alle Fenster-Knoten aus $S$ und alle Fenster-Kanten aus $S$
  und nichts sonst.
  \item Falls der GSL Interpreter im Kontext eines Anzeigefensters ausgeführt
  wird und in diesem Anzeigefenster keine Selektion mit Namen \nidentifier
  existiert, so ist das Ergebnis dieser Inspektion der Wert \toknull.
  \item Falls der GSL Interpreter nicht im Kontext eines Anzeigefensters
  ausgeführt wird, so ist die Auswertung dieser Inspektion ein Laufzeitfehler.
  \item Formal erfolgt eine Inspektion der Variable mit Namen
  \tokselection.\nidentifier. Diese Variable ist, falls der GSL Interpreter
  im Kontext eines Anzeigefensters ausgeführt wird, in der
  Aktivierungsumgebung \bottomenv gebunden und deshalb sichtbar. Falls
  der GSL Interpreter nicht im Kontext eines Anzeigefensters ausgeführt wird,
  so existiert die Variable nicht.
  \end{enumerate}
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Referenz}

\begin{EBNF}
\item[\nreference] \nvisibleref | \nvarcreation | \nglobalref
\end{EBNF}

\begin{enumerate}
\item Eine \nreference nimmt die Referenz einer Variable (siehe
\ref{variable_reference}). Die verschiedenen rechten Seiten werden
verwendet um Variablen zu unterscheiden, die in verschiedenen
Aktivierungsumgebungen gebunden sind.
\item Das Ergebnis der \nreference ist identisch mit dem Ergebnis der
gewählten rechten Seite.
\end{enumerate}

\begin{EBNF}
\item[\nvisibleref] \toktick \nidentifier
\end{EBNF}

\begin{enumerate}
\item Nimmt die Referenz der Variable mit Name
\nidentifier, die in der aktuellen Aktivierungsumgebung sichtbar ist
(siehe \ref{visibility}).
\item Falls in der aktuellen Aktivierungsumgebung keine sichtbare Variable
dieses Namens existiert, so führt die
Auswertung zu einem Laufzeitfehler. Andernfalls ist die Auswertung
erfolgreich.
\item Falls die Auswertung erfolgreich ist, so ist das Ergebnis ein
Zugriffspfad auf das Objekt an das die Variable gebunden ist.
\end{enumerate}

\begin{EBNF}
\item[\nvarcreation] \tokplus \nidentifier
\end{EBNF}

\begin{enumerate}
\item Bindet in der aktuellen Aktivierungsumgebung (siehe \ref{current_env})
die Variable mit Namen \nidentifier an ein neues Objekt.
\item Falls in der aktuellen Aktivierungsumgebung bereits eine Variable
mit diesem Namen gebunden war, so führt die Auswertung zu einem Laufzeitfehler.
Andernfalls ist die Auswertung erfolgreich.
\item Das neue Objekt hat den Wert \toknull.
\end{enumerate}

\begin{EBNF}
\item[\nglobalref] \toktick $\langle$ \toksubgraph | \tokselection $\rangle$
                              \tokdot \nidentifier
\end{EBNF}

\begin{enumerate}
\item Falls \toksubgraph angegeben ist:
  \begin{enumerate}
  \item Diese Zugriffspfadbestimmung ist eine Schnittstelle zu GIANT.
  \item Falls in GIANT kein IML-Teilgraph mit Name \nidentifier existiert, dann
  erzeugt GIANT diesen IML-Teilgraph. Er enthält keine Graph-Knoten und keine
  Graph-Kanten.
  \item Das Ergebnis ist ein Zugriffspfad auf den IML-Teilgraph mit Name
  \nidentifier.
  \end{enumerate}
\item Falls \tokselection angegeben ist:
  \begin{enumerate}
  \item Diese Zugriffspfadbestimmung ist eine Schnittstelle zu GIANT.
  \item Falls der GSL Interpreter nicht im Kontext eines Anzeigefensters
  ausgeführt wird, so führt die Auswertung dieser Zugriffspfadbestimmung zu
  einem Laufzeitfehler. Andernfalls ist die Auswertung erfolgreich.
  \item Ist die Auswertung erfolgreich und existiert im Anzeigefenster keine
  Selektion mit Name \nidentifier, so erzeugt GIANT im Anzeigefenster diese
  Selektion. Sie enthält keine Fenster-Knoten und keine Fenster-Kanten.
  \item Ist die Auswertung erfolgreich, so ist das Ergebnis ein Zugriffspfad
  auf die Selektion mit Name \nidentifier in dem Anzeigefenster, in dessen
  Kontext der GSL Interpreter ausgeführt wird.
  \end{enumerate}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Scriptdeklaration}
\label{script_decl}

\begin{EBNF}
\item[\nscriptdecl] \tokcurlyopen \nlist \nexpression \tokcurlyclose
\end{EBNF}

\begin{enumerate}
\item Eine \nscriptdecl deklariert ein neues Script $S$.
\item Ergebnis ist eine Aktivierungsinformation $I$ vom Typ
\tscriptreference für $S$.
\item Die zulässige Aktivierungsumgebung in $I$ ist die (zum Zeitpunkt der
Auswertung der \nscriptdecl) aktuelle Aktivierungsumgebung.
\item Die \nlist heißt Parameterliste von $S$ (vgl. \ref{script_activation}).
\item Die \nexpression heißt Rumpf von $S$ (vgl. \ref{script_activation}).
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Liste}

\begin{EBNF}
\item[\nlist] \tokopenbracket $\langle$ \nexpression
                $\langle$ \tokcomma \nexpression $\rangle$*
              $\rangle ?$ \tokclosebracket
\end{EBNF}

\begin{enumerate}
\item Eine \nlist kann ausgewertet werden und hat als Ergebnis einen Wert
vom Typ \tlist.
\item Zur Auswertung einer \nlist werden der Reihe nach von links nach rechts
alle \nexpression ausgewertet, falls überhaupt welche angegeben sind.
\item Die Auswertung führt zu einem Laufzeitfehler, falls die Auswertung einer
der \nexpression zu einem Laufzeitfehler führt. Andernfalls ist die Auswertung
erfolgreich.
\item Falls die Auswertung erfolgreich ist, so ist das Ergebnis ein Wert
vom Typ \tlist, der die Ergebnisse aller \nexpression in
ihrer korrekten Reihenfolge enthält und sonst nichts.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Sequenz}

\begin{EBNF}
\item[\nsequence] \tokbeginsequence $\langle$ \nexpression
                  \toksemicolon $\rangle$* \tokendsequence
\end{EBNF}

\begin{enumerate}
\item Eine \nsequence kann ausgewertet werden und hat ein Ergebnis.
\item Zur Auswertung einer \nsequence werden der Reihe nach von links nach
rechts alle \nexpression ausgewertet, falls überhaupt welche angegeben sind.
\item Die Auswertung führt zu einem Laufzeitfehler, falls die Auswertung einer
der \nexpression zu einem Laufzeitfehler führt. Andernfalls ist die Auswertung
erfolgreich.
\item Falls die Auswertung erfolgreich ist, so ist das Ergebnis der Wert,
den die Auswertung der letzten (der am weitesten rechts stehenden)
\nexpression zum Ergebnis hatte. Falls die \nsequence keine \nexpression
enthält, so ist das Ergebnis \toknull.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Scriptaktivierung}
\label{script_activation}

\begin{EBNF}
\item[\nscriptactivation] \nexpression \nlist
\end{EBNF}

\begin{enumerate}
\item Die \nexpression wird ausgewertet und hat als Ergebnis den Wert $I$.
\item Die \nlist wird ausgewertet.
\item $I$ muss vom Typ \tscriptreference sein.
Andernfalls führt die Auswertung zu einem Laufzeitfehler. $I$ enthält einen
Zugriffspfad auf das Skript $S$.
\item Es wird eine neue Aktivierungsumgebung $A$ erzeugt. $A$ beerbt die
  in $I$ angegebene zulässige Aktivierungsumgebung
  (siehe \ref{script_decl}, \ref{activation_preconds}). \label{new_activation}
\item $A$ wird aktuelle Aktivierungsumgebung.
\item Die Parameterliste $P$ von $S$ wird ausgewertet.
\item $P$ muss genauso viele Werte enthalten wie \nlist, andernfalls ist
  dies ein Laufzeitfehler.
\item Falls einer der Werte
  in $P$ nicht vom Typ \tvarreference ist, so ist dies ein Laufzeitfehler.
\item Den \tvarreference in $P$ werden die Werte der Einträge des Werts von
  \nlist zugewiesen
  (genaue Beschreibung siehe \ref{parameter_passing}).
\item Die \nexpression des durch $I$ referenzierten Scripts wird
ausgewertet und hat den Wert $R$ als Ergebnis.
$R$ darf ein Wert eines beliebigen Typs sein mit den Einschränkungen:
    \begin{enumerate}
    \item Ist $R$ vom Typ \tvarreference, dann ist $R$ ein Zugriffspfad
    auf ein Objekt, das in einer Aktivierungsumgebung \oldenv an eine
    Variable gebunden ist. Es muss gelten: \oldenv $< A$. Andernfalls liegt
    ein Laufzeitfehler vor.\\
    \textbf{Hinweis}
    Diese Einschränkung erzwingt, dass $R$ nicht ein Zugriffspfad auf
    ein Objekt sein kann, das an eine lokale Variable gebunden ist.
    \item Ist $R$ vom Typ \tscriptreference, dann ist $R$ eine
    Aktivierungsinformation. Die zulässige Aktivierungsumgebung dieser
    Aktivierungsinformation sei \oldenv. Es muss gelten: \oldenv $< A$. 
    Andernfalls liegt ein Laufzeitfehler vor.\\
    \textbf{Hinweis}
    Diese Einschränkung erzwingt, dass die Aktivierung von $R$ nicht
    die Existenz der (während der Auswertung von $S$) aktuellen
    Aktivierungsumgebung $A$ erfordert.
    \end{enumerate}
  \label{script_result}
\item $A$ wird zerstört. Alle Objekte, die von lokalen Variablen in $A$
  gebunden wurden dürfen zerstört werden.
\item Die Aktivierungsumgebung, die zuvor (bis zum Schritt
   \ref{new_activation}) aktuell war, wird wieder aktuell.
\item Falls kein Laufzeitfehler aufgetreten ist, so ist das Ergebnis der
  Auswertung der Wert $R$ (siehe Punkt \ref{script_result}).
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\raggedbottom
\section{Vordefinierte Sprachumgebung}
\label{predef_env}

\newenvironment{scriptdef}[1]
{%begin
  \begin{tabular}{|p{0.2\textwidth} p{0.2\textwidth} p{0.5\textwidth}|}
  \multicolumn{3}{l}{\textbf{{\large #1}}} \\
  \hline
}
{%end
  \hline
  \end{tabular}
}

\newcommand{\sparam}[3]{#1 & #2 & #3 \\}
\newcommand{\sresult}[2]{\hline \textbf{Ergebnis} & #1 & #2 \\}
\newcommand{\saction}[1]{\hline \multicolumn{3}{|p{0.9\textwidth}|}{#1} \\}


In diesem Kapitel werden Scripts beschrieben, die in GSL standardmäßig zur
Verfügung stehen. Dabei wird folgende Form verwendet:

\begin{scriptdef}{Variablenname}
\sparam{Param\_Name}{Typ}{Beschreibung des Parameters. In der Spalte \gq{Typ}
werden alle möglichen Typen aufgelistet, die zulässig sind. Falls ein Wert
eines anderen Typs übergeben wird, so soll während der Auswertung des Scripts
ein Laufzeitfehler auftreten.}
\sparam{Second\_Name}{Typ}{Die Parameter werden in der Reihenfolge
aufgelistet, in der die entsprechenden Argumente angegeben werden müssen.}
\sresult{Typ}{Beschreibung des Ergebnis, in der Spalte \gq{Typ} wird eine
Zusicherung angegeben. Das Ergebnis muss ein Wert dieses Typs sein.}
\saction{Beschreibung der Funktion und des genauen Ablaufs des Scripts.
Der Variablenname ist der Name einer Variable, deren Inspektion eine
\tscriptreference auf das beschriebene Script zum Ergebnis hat.}
\end{scriptdef}


\subsection{Elementare Scripts}

Die hier beschriebenen Scripts realisieren elementare Funktionalität,
die der GSL
Interpreter direkt zur Verfügung stellt. Der GSL Interpreter erzeugt die
Objekte, in denen die Aktivierungsinformation gespeichert ist vor
Beginn einer Auswertung. Der GSL
Interpreter erzeugt die hier genannten Variablen in der
Aktivierungsumgebung \bottomenv.

\subsubsection{Zuweisung}

%%% set
\begin{scriptdef}{set}
\sparam{lhs}{\tvarreference}{Zugriffspfad auf eine sichtbare Variable}
\sparam{rhs}{jeder Typ}{Zuzuweisender Wert eines beliebigen Typs. Es gibt
jedoch gewisse Einschränkungen (siehe Beschreibung)}
\sresult{}{\toknull}
\saction{Das Objekt, das durch lhs referenziert wird, ändert seinen Wert
zu rhs. Falls rhs einen Wert eines der Typen 
  \begin{enumerate}
  \item \tscriptreference
  \item \tvarreference
  \end{enumerate}
hat, so muss für die Aktivierungsumgebungen gelten: $A_{rhs} \le A_{lhs}$,
andernfalls führt die Auswertung zu einem Laufzeitfehler.

$A_{lhs}$ ist dabei die kleinste Aktivierungsumgebung, in der das durch lhs
referenzierte Objekt an eine Variable gebunden ist. $A_{rhs}$ ist die kleinste
Aktivierungsumgebung, in der das durch $A_{rhs}$ referenzierte Objekt
an eine Variable gebunden ist.

Durch diese Einschränkung wird sichergestellt, dass zu keinem Zeitpunkt ein
Wert eines der Typen \tscriptreference oder \tvarreference existiert,
der ein Objekt referenziert, das an keine Variable gebunden ist. Dieser Fall
könnte sonst eintreten nachdem eine Aktivierungsumgebung zerstört wurde.}
\end{scriptdef}

%%% deref
\begin{scriptdef}{deref}
\sparam{ref}{\tvarreference}{Zugriffspfad auf ein Objekt eines
  beliebigen Typs}
\sresult{Typ des Werts des referenzierten Objekts}{Wert des Objekts,
  das durch ref referenziert wird}
\saction{Liefert den Wert des Objekts, das durch eine Referenz gegeben
  wird. \gq{Dereferenziert} eine Referenz}
\end{scriptdef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Kontrollfluss}

%%% if
\begin{scriptdef}{if}
\sparam{condition}{\tboolean}{Ein Wert vom Typ
\tboolean}
\sparam{true\_branch}{jeder Typ}{Falls der Typ \tscriptreference ist, so muss
true\_branch die Aktivierunginformation für ein parameterloses Script sein,
dessen Ergebnis beliebigen Typs sein darf.}
\sparam{false\_branch}{jeder Typ}{Falls der Typ \tscriptreference ist, so muss
false\_branch die Aktivierunginformation für ein parameterloses Script sein,
dessen Ergebnis beliebigen Typs sein darf.}
\sresult{von Argumenten abhängig}{Siehe Beschreibung}
\saction{Falls condition erfüllt ist, so ist $c = $ true\_branch, andernfalls
$c = $ false\_branch.

Falls $c$ eine Aktivierungsinformation ist, so wird das referenzierte
Script ohne Argumente aktiviert. Ergebnis des Scripts if ist das Ergebnis
von $c$. Falls $c$ keine Aktivierungsinformation ist, so ist das Ergebnis
des Scripts if der Wert von $c$. \textbf{Vorsicht:} falls der Ausdruck
in true\_branch oder false\_branch Seiteneffekte hat, so ist ist die Übergabe
einer Aktivierungsinformation geraten. Andernfalls würde der Ausdruck
ausgewertet unabhängig davon, ob condition erfüllt ist, oder nicht.}
\end{scriptdef}

%%% loop
\begin{scriptdef}{loop}
\sparam{body}{\tscriptreference}{Aktivierungsinformation für parameterloses
Script mit Ergebnistyp \tboolean}
\sresult{}{\toknull}
\saction{Aktiviert body. Falls body das Ergebnis \toktrue hat, aktiviert
body so oft ein weiteres Mal, bis body das Ergebnis \tokfalse hat.}
\end{scriptdef}

%%% error
\begin{scriptdef}{error}
\sparam{message}{\tstring}{Fehlermeldung}
\sresult{}{}
\saction{Löst einen Laufzeitfehler geziehlt aus und veranlasst den GSL
Interpreter dem Benutzer die Fehlermeldung message anzuzeigen.}
\end{scriptdef}

%%% run
\begin{scriptdef}{run}
\sparam{file\_name}{\tstring}{Name einer Bibliothek. An diesen Namen wird
noch der Text \gq{.gsl} angehängt}
\sresult{}{Ergebnis des ausgeführten Ausdrucks}
\saction{An den file\_name wird \gq{.gsl} angehängt. Dann sucht der GSL
Interpreter die Standard Directories nach einem File mit dem Namen.
Dann führt der GSL Interpreter den in diesem File enthaltenen GSL Ausdruck
in der aktuellen Aktivierungsumgebung aus. Mit Hilfe dieses Scripts können
Bibliotheken von benutzerdefinierten Scripts geladen werden. Eine Bibliothek
sollte eine \nsequence sein und in den \nexpression der \nsequence sollten
neue Variablen erzeugt werden, die die Aktivierungsinformation von den
Scripts der Bibliothek enthalten. \textbf{Hinweis} run ist das einzige
Script, zu dessen Aktivierung keine neue Aktivierungsumgebung erzeugt werden
muss. Der Ausdruck aus der geladenen Datei wird direkt in der aktuellen
Aktivierungsumgebung ausgeführt.}
\end{scriptdef}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Rechenoperationen}

%%% add
\label{scriptdef_add}
\begin{scriptdef}{add}
\sparam{a}{\tnatural oder \tvarreference}{Entweder eine Zahl oder ein
Zugriffspfad auf ein Objekt, das einen Wert aus \tnodeset oder \tedgeset hat}
\sparam{b}{\tnatural bzw.\ \tnodeid bzw.\ \tedgeid bzw.\ \tnodeset
bzw.\ \tedgeset bzw.\ \tvarreference}{Abhängig von dem Typ
von a ebenfalls eine Zahl oder der entsprechende Elementtyp oder eine
entsprechende Menge oder ein Zugriffspfad auf ein Objekt des
entsprechenden Mengen-Typs}
\sresult{\tnatural bzw.\ der namenlose Typ}{Abhängig von den Argumenten
entweder die Summe der beiden Zahlen oder der Wert \toknull}
\saction{Es werden verschiedene Verwendungen unterschieden:
\begin{enumerate}
\item a ist vom Typ \tnatural und b ist vom Typ \tnatural. Dann hat
die Aktivierung dieses Script die Summe der beiden Zahlen als
Ergebnis. Es ist ein Laufzeitfehler, falls der
(implementationsabhängige) maximale Wertebereich überschritten wird.
\item a ist vom Typ \tvarreference und hat als Wert einen Zugriffspfad auf
ein Objekt, dessen Wert $N$ vom Typ \tnodeset ist. Das Ergebnis der
Script-Aktivierung ist in diesem Fall stets \toknull.
  \begin{enumerate}
  \item Falls b vom Typ \tnodeid ist, dann wird der Wert $N$ um das
  Element b vergrößert, falls b zuvor noch nicht in $N$ enthalten war, 
  andernfalls wird nichts getan.
  \item Falls b vom Typ \tnodeset ist, dann wird die Vereinigung von
  $N$ und b gebildet und dem Objekt, das durch a referenziert wird,
  zugewiesen.
  \item Falls b vom Typ \tvarreference ist, dann muss b ein
  Zugiffspfad auf ein Objekt sein, dessen Wert $N_r$ vom Typ \tnodeset
  ist. In diesem Fall wird die Vereinigung von $N$ und $N_r$ gebildet
  und dem Objekt, das durch a referenziert wird, zugewiesen.
  \item Falls keiner dieser Fälle zutrifft, so ist dies ein Laufzeitfehler.
  \end{enumerate}
\item a ist vom Typ \tvarreference und hat als Wert einen Zugriffspfad auf
ein Objekt, dessen Wert $E$ vom Typ \tedgeset ist. Das Ergebnis der
Script-Aktivierung ist in diesem Fall stets \toknull.
  \begin{enumerate}
  \item Falls b vom Typ \tedgeid ist, dann wird der Wert $E$ um das
  Element b vergrößert, falls b zuvor noch nicht in $E$ enthalten war, 
  andernfalls wird nichts getan.
  \item Falls b vom Typ \tedgeset ist, dann wird die Vereinigung von
  $E$ und b gebildet und dem Objekt, das durch a referenziert wird,
  zugewiesen.
  \item Falls b vom Typ \tvarreference ist, dann muss b ein
  Zugiffspfad auf ein Objekt sein, dessen Wert $E_r$ vom Typ \tedgeset
  ist. In diesem Fall wird die Vereinigung von $E$ und $E_r$ gebildet
  und dem Objekt, das durch a referenziert wird, zugewiesen.
  \item Falls keiner dieser Fälle zutrifft, so ist dies ein Laufzeitfehler.
  \end{enumerate}
\end{enumerate}}
\end{scriptdef}

%%% sub
\label{scriptdef_sub}
\begin{scriptdef}{sub}
\sparam{a}{\tnatural oder \tvarreference}{Entweder eine Zahl oder ein
Zugriffspfad auf ein Objekt, das einen Wert aus \tnodeset oder \tedgeset hat}
\sparam{b}{\tnatural bzw.\ \tnodeid bzw.\ \tedgeid bzw.\ \tnodeset
bzw.\ \tedgeset bzw.\ \tvarreference}{Abhängig von dem Typ
von a ebenfalls eine Zahl oder der entsprechende Elementtyp oder der
entsprechende Mengentyp oder ein Zugriffspfad auf ein Objekt des
entsprechenden Mengentyps}
\sresult{\tnatural bzw.\ der namenlose Typ}{Abhängig von den Argumenten
entweder die Differenz der beiden Zahlen oder der Wert \toknull}
\saction{Es werden verschiedene Verwendungen unterschieden:
\begin{enumerate}
\item a ist vom Typ \tnatural und b ist vom Typ \tnatural. Dann hat
dieses Script die Differenz a $-$ b der beiden Zahlen als Ergebnis. Es ist ein
Laufzeitfehler, falls der (implementationsabhängige) maximale Wertebereich
überschritten wird.
\item a ist vom Typ \tvarreference und hat als Wert einen Zugriffspfad auf
ein Objekt, dessen Wert $N$ vom Typ \tnodeset ist. Das Ergebnis der
Script-Aktivierung ist in diesem Fall stets \toknull.
  \begin{enumerate}
  \item Falls b vom Typ \tnodeid ist, dann wird $N$ um das Element b
  verkleinert, falls b zuvor in $N$ enthalten war, andernfalls wird
  nichts getan.
  \item Falls b vom Typ \tnodeset ist, dann wird die Differenz $N-$ b
  gebildet und dem Objekt zugewiesen, das durch a referenziert wird.
  \item Falls b vom Typ \tvarreference ist, dann muss b ein Objekt
  referenzieren, dessen Wert $N_r$ vom Typ \tnodeset ist. In diesem
  Fall wird die Differenz $N-N_r$ gebildet und dem Objekt, das durch
  a referenziert wird, zugewiesen.
  \item Falls keiner dieser Fälle zutrifft, so ist dies ein Laufzeitfehler.
  \end{enumerate}
\item a ist vom Typ \tvarreference und hat als Wert einen Zugriffspfad auf
ein Objekt, dessen Wert $E$ vom Typ \tedgeset ist. Das Ergebnis der
Script-Aktivierung ist in diesem Fall stets \toknull.
  \begin{enumerate}
  \item Falls b vom Typ \tedgeid ist, dann wird der Wert $E$ um das
  Element b verkleinert, falls b zuvor in $E$ enthalten war,
  andernfalls wird nichts getan.
  \item Falls b vom Typ \tedgeset ist, dann wird die Differenz $E-$ b
  gebildet und dem Objekt zugewiesen, das durch a referenziert wird.
  \item Falls b vom Typ \tvarreference ist, dann muss b ein Objekt
  referenzieren, dessen Wert $E_r$ vom Typ \tedgeset ist. In diesem
  Fall wird die Differenz $E-E_r$ gebildet und dem Objekt, das durch
  a referenziert wird, zugewiesen.
  \item Falls keiner dieser Fälle zutrifft, so ist dies ein Laufzeitfehler.
  \end{enumerate}
\end{enumerate}}
\end{scriptdef}

%%% cat
\begin{scriptdef}{cat}
\sparam{left}{\tstring}{Der linke String}
\sparam{right}{\tstring}{Der rechte String}
\sresult{\tstring}{Konkatenation von left und right}
\saction{Berechnet die Konkatenation zweier Strings.}
\end{scriptdef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Vergleiche}

%%% less
\begin{scriptdef}{less}
\sparam{a}{\tnatural, \tedgeid, \tnodeid, \tstring}{}
\sparam{b}{der selbe Typ wie a}{}
\sresult{\tboolean}{Ergebnis der Ungleichung a < b}
\saction{Berechet Enthaltensein des Paars (a, b) in einer irreflexiven
antisymmetrischen und transitiven binären Relation. Die Relation ist auf den
verschiedenen Typen folgendermaßen definiert:
\begin{description}
\item[\tnatural] Wie in der Mathematik für < üblich.
\item[\tedgeid] Implementationsabhängig, hat keine besondere Semantik, kann
verwendet werden um eine konsistente Sortierung verschiedener Listen zu
erreichen.
\item[\tnodeid] Implementierungsabhängig, hat keine besondere Semantik, kann
verwendet werden um eine konsistente Sortierung verschiedener Listen zu
erreichen.
\item[\tstring] Imlementierungsabhängige lexikographische Ordnung.
\end{description}}
\end{scriptdef}

%%% equal
\begin{scriptdef}{equal}
\sparam{a}{\tnatural, \tedgeid, \tnodeid, \tstring}{}
\sparam{b}{der selbe Typ wie a}{}
\sresult{\tboolean}{\toktrue, falls a und b gleiche Werte sind,
\tokfalse sonst}
\saction{Testet ob a = b.}
\end{scriptdef}

%%% in_regexp
\begin{scriptdef}{in\_regexp}
\sparam{s}{\tstring}{Teststring}
\sparam{regexp}{\tstring}{Ein regulärer Ausdruck nach der Spezifikation
des Ada95 Pakets GNAT.Reg\_Pat}
\sresult{\tboolean}{\toktrue falls s in der durch regexp beschriebenen Sprache
enthalten ist, \tokfalse sonst}
\saction{Ermittelt, ob ein String in der Sprache eines regulären Ausdrucks
enthalten ist. Es ist ein Laufzeitfehler, falls regexp syntaktisch nicht
korrekt ist.}
\end{scriptdef}

%%% type_in
\begin{scriptdef}{type\_in}
\sparam{type}{\tstring}{Typname eines IML-Knoten oder einer IML-Kante}
\sparam{class\_set}{\tstring}{Name einer Klassenmenge in GIANT}
\sresult{\tboolean}{\toktrue falls type in class\_set enthalten ist, \tokfalse
sonst}
\saction{Testet ob der Typname type in der Klassenmenge class\_set enthalten
ist. Der Typname einer IML-Kante hat das Format \gq{Knotentyp.Attributname}.
Es ist ein Laufzeitfehler, falls class\_set kein Name einer Klassenmenge
ist.}
\end{scriptdef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Mengen und Listen}

In dieses Kapitel gehören auch die Variablen \textbf{add} und \textbf{sub}.
Da diese jedoch nicht ausschließlich auf Mengen angewendet werden, sind
sie in dem allgemeineren Kapitel \ref{scriptdef_add} aufgeführt.

%%% empty_node_set
\begin{scriptdef}{empty\_node\_set}
\sresult{\tnodeset}{Ein Wert $M$ mit equal (size\_of ($M$), 0)}
\saction{Hat als Ergebnis eine leere Knotenmenge.}
\end{scriptdef}

%%% empty_edge_set
\begin{scriptdef}{empty\_edge\_set}
\sresult{\tedgeset}{Ein Wert $M$ mit equal (size\_of ($M$), 0)}
\saction{Hat als Ergebnis eine leere Kantenmenge.}
\end{scriptdef}

%%% get_first
\begin{scriptdef}{get\_first}
\sparam{set}{\tnodeset oder \tedgeset oder \tvarreference}{Eine Menge
von Knoten, eine Menge von Kanten oder eine Referenz auf ein Objekt,
dessen Wert vom Type \tnodeset oder \tedgeset ist}
\sresult{\tnodeid oder \tedgeid}{Ein Element $e$ mit is\_in (set,
$e$)}
\saction{Hat als Ergebnis ein (von der Implementierung willkürlich
gewähltes)  Element aus der Menge. Es ist ein Laufzeitfehler, falls
die Menge leer ist.}
\end{scriptdef}

%%% is_in
\begin{scriptdef}{is\_in}
\sparam{set}{\tnodeset oder \tedgeset oder \tvarreference}{Ein Wert
eines der Mengentypen oder eine Referenz auf ein Objekt, dessen Wert
in einem der Mengentypen liegt}
\sparam{element}{\tnodeid bzw.\ \tedgeid}{Ein Element, der Typ muss zum
Argument set passend sein. Falls set ein Wert aus \tnodeset ist, so muss
element ein Wert vom Typ \tnodeid sein. Falls set ein Wert aus \tedgeset
ist, so muss element ein Wert vom Typ \tedgeid sein. Entsprechendes
gilt, falls set eine \tvarreference ist.}
\sresult{\tboolean}{\toktrue, falls element in set enthalten ist, \tokfalse
sonst}
\saction{Testet, ob element in set bzw.\ der durch set referenzierten
Menge enthalten ist.}
\end{scriptdef}

%%% size_of
\begin{scriptdef}{size\_of}
\sparam{obj}{\tlist oder \tnodeset oder \tedgeset oder \tvarreference}
{Irgendeine Liste, oder eine Menge oder ein Zugriffspfad auf ein
Objekt des Types \tnodeset oder \tedgeset.}
\sresult{\tnatural}{Anzahl der Werte in obj}
\saction{Ermittelt die Anzahl der Einträge der Liste bzw.\ die Kardinalität
der Menge.}
\end{scriptdef}

%%% get_entry
\begin{scriptdef}{get\_entry}
\sparam{list}{\tlist}{Irgendeine nicht-leere Liste}
\sparam{index}{\tnatural}{Index des gewünschten Eintrags. Der am weitesten
links stehende Eintrag hat die Nummer 1, der am weitesten rechts stehende
hat die Nummer size\_of (list)}
\sresult{}{Wert des index-ten Eintrags von list}
\saction{Ermittelt den Wert eines bestimmten Eintrags von list}
\end{scriptdef}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Typfeststellungen}

%%% is_nodeid
\begin{scriptdef}{is\_nodeid}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tnodeid ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tnodeid ist.}
\end{scriptdef}

%%% is_edgeid
\begin{scriptdef}{is\_edgeid}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tedgeid ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tedgeid ist.}
\end{scriptdef}

%%% is_node_set
\begin{scriptdef}{is\_node\_set}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tnodeset ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tnodeset ist.}
\end{scriptdef}

%%% is_edge_set
\begin{scriptdef}{is\_edge\_set}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tedgeset ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tedgeset ist.}
\end{scriptdef}

%%% is_string
\begin{scriptdef}{is\_string}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tstring ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tstring ist.}
\end{scriptdef}

%%% is_boolean
\begin{scriptdef}{is\_boolean}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tboolean ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tboolean ist.}
\end{scriptdef}

%%% is_natural
\begin{scriptdef}{is\_natural}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tnatural ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tnatural ist.}
\end{scriptdef}

%%% to_natural
\begin{scriptdef}{to\_natural}
\sparam{str}{\tstring}{Ein String}
\sresult{\tnatural}{Interpretation des Werts von str als Zahl im 10-er
Stellenwertsystem}
\saction{Wandelt einen Text, der eine Zahl im 10-er Stellenwertsystem
  darstellt nach \tnatural um. Falls der Text keine korrekt kodierte
  Zahl darstellt, so ist dies ein Laufzeitfehler.}
\end{scriptdef}

%%% is_list
\begin{scriptdef}{is\_list}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tlist ist, \tokfalse
andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tlist ist.}
\end{scriptdef}

%%% is_reference
\begin{scriptdef}{is\_reference}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tvarreference ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tvarreference ist.}
\end{scriptdef}

%%% is_script
\begin{scriptdef}{is\_script}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert vom Typ \tscriptreference
ist, \tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom Typ \tscriptreference ist.}
\end{scriptdef}

%%% is_null
\begin{scriptdef}{is\_null}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert des namenlosen Typs ist,
\tokfalse andernfalls.}
\saction{Überprüft, ob der Wert von obj der Wert \toknull des namenlosen
Typs ist.}
\end{scriptdef}

%%% is_object_set
\begin{scriptdef}{is\_object\_set}
\sparam{obj}{jeder Typ}{Der Wert irgendeines Ausdrucks}
\sresult{\tboolean}{\toktrue, falls obj ein Wert des zusammengesetzten
Typs \tobjectset ist, \tokfalse andernfalls.}
\saction{Überprüft, ob der Wert obj vom zusammengesetzten Typ \tobjectset ist.}
\end{scriptdef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Interaktion mit GIANT}

In diesem Kapitel werden alle Aktionen und alle Anfragen definiert, die mit
GSL ausgelöst werden können.

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Interaktion mit dem GSL Interpreter}

%%% get_current_window
\begin{scriptdef}{get\_current\_window}
\sresult{\tstring oder der namenlose Typ}{Name des Anzeigefensters oder
\toknull}
\saction{Falls der GSL Interpreter im Kontext eines Anzeigefenster ausgeführt
wird, hat dieses Script als Ergebnis den Namen dieses Anzeigefensters.
Andernfalls ist das Ergebnis der Wert \toknull.}
\end{scriptdef}

%%% set_current_window
\begin{scriptdef}{set\_current\_window}
\sparam{window\_name}{\tstring}{Name eines Anzeigefensters}
\sresult{\tboolean}{\toktrue, falls der Kontext des GSL Interpreters geändert
wurde, \tokfalse sonst}
\saction{Ändert den Kontext des GSL Interpreters, so dass der GSL Interpreter
danach im Kontext des Anzeigefensters mit Namen window\_name ausgeführt
wird. Diese Aktion kann aus einer Vielzahl von Gründen fehlschlagen. Ein
GSL Interpreter darf den Wechsel des Kontexts verbieten, falls kein
Anzeigefenster mit Namen window\_name existiert oder falls Objekte existieren,
die Referenzen auf Selektionen in einem anderen Anzeigefenster enthalten.
Auf jeden Fall sollte deshalb das Ergebnis dieses Scripts beachtet werden.}
\end{scriptdef}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Anfragen an den IML-Graph}

%%% root_node
\begin{scriptdef}{root\_node}
\sresult{\tnodeid}{Der Wurzelknoten des IML-Graphen}
\saction{Hat als Ergebnis den Wurzelknoten des IML-Graphen.}
\end{scriptdef}

%%% all_nodes
\begin{scriptdef}{all\_nodes}
\sresult{\tnodeset}{Menge aller IML-Knoten des IML-Graph}
\saction{Hat als Ergebnis die Menge aller IML-Knoten des IML-Graph.}
\end{scriptdef}

%%% all_edges
\begin{scriptdef}{all\_edges}
\sresult{\tedgeset}{Menge aller IML-Kanten des IML-Graph}
\saction{Hat als Ergebnis die Menge aller IML-Kanten des IML-Graph.}
\end{scriptdef}

%%% instance_of
\begin{scriptdef}{instance\_of}
\sparam{node}{\tnodeid}{Ein IML-Knoten}
\sparam{class}{\tstring}{Name einer Klasse von IML-Knoten}
\sresult{\tboolean}{\toktrue falls node eine Instanz der Klasse von
  IML-Knoten class ist. \tokfalse sonst.}
\saction{Prüft, ob ein IML-Knoten eine Instanz einer Klasse von
  IML-Knoten ist. Dies ist der Fall, falls node der Klasse class
  angehört, oder falls node die Klasse von IML-Knoten mit Name class
  (auch transitiv) beerbt. Falls class durch die Reflektion nicht als
  Name einer Klasse von IML-Knoten spezifiziert ist, so ist dies ein
  Laufzeitfehler.}
\end{scriptdef}

%%% has_attribute
\begin{scriptdef}{has\_attribute}
\sparam{n}{\tnodeid}{Ein IML-Knoten}
\sparam{attrib}{\tstring}{Name eines Attributs}
\sresult{\tboolean}{\toktrue, falls der IML-Knoten n ein Attribut mit Name
attrib besitzt, \tokfalse sonst}
\saction{Testet, ob ein bestimmter IML-Knoten ein bestimmtes Attribut besitzt.}
\end{scriptdef}

%%% get_attribute
\begin{scriptdef}{get\_attribute}
\sparam{n}{\tnodeid}{Ein IML-Knoten}
\sparam{attrib}{\tstring}{Name eines Attributs}
\sresult{}{Wert des Attributs oder \toknull}
\saction{Stellt fest, ob der IML-Knoten n ein Attribut mit Namen attrib
besitzt. Falls nein ist das Ergebnis \toknull. Andernfalls ist das Ergebnis
der Wert des Attributs. Solche Werte, die in der Reflektion durch einen
Enumerator dargestellt werden, werden hier als \tlist dargestellt.}
\end{scriptdef}

%%% get_type
\begin{scriptdef}{get\_type}
\sparam{obj}{\tnodeid oder \tedgeid}{Ein IML-Knoten oder eine IML-Kante}
\sresult{\tstring}{Typ von obj}
\saction{Ergebnis ist die Typbezeichnung von obj. Für einen IML-Knoten ist
dieser Text identisch mit dem Typname. Für eine IML-Kante setzt sich dieser
Text zusammen aus Name des Typs des Startknoten . Name des Attributs dieser
IML-Kante.}
\end{scriptdef}

%%% get_incoming
\begin{scriptdef}{get\_incoming}
\sparam{n}{\tnodeid}{Ein IML-Knoten}
\sresult{\tedgeset}{Vorbereich von n}
\saction{Ermittelt alle IML-Kanten, die als Target n haben.}
\end{scriptdef}

%%% get_outgoing
\begin{scriptdef}{get\_outgoing}
\sparam{e}{\tnodeid}{Ein IML-Knoten}
\sresult{\tedgeset}{Nachbereich von n}
\saction{Ermittelt alle IML-Kanten, die n als Source haben.}
\end{scriptdef}

%%% get_source
\begin{scriptdef}{get\_source}
\sparam{e}{\tedgeid}{Eine IML-Kante}
\sresult{\tnodeid}{Startknoten von e}
\saction{Ermittelt den Startknoten einer IML-Kante.}
\end{scriptdef}

%%% get_target
\begin{scriptdef}{get\_target}
\sparam{e}{\tedgeid}{Eine IML-Kante}
\sresult{\tnodeid}{Zielknoten von e}
\saction{Ermittelt den Zielknoten einer IML-Kante.}
\end{scriptdef}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Anfragen an die GUI}

%%% input
\begin{scriptdef}{input}
\sparam{info}{\tstring}{Information, die dem Benutzer angezeigt wird.}
\sresult{\tstring}{Text, den der Benutzer eingegeben hat, oder der
  leere String, falls der Benutzer die Eingabe abgebrochen hat.}
\saction{Zeigt in GIANT ein Dialogfenster an. In diesem Dialogfenster
  wird info angezeigt. Der Benutzer kann in ein Eingabefeld einen Text
  eingeben.}
\end{scriptdef}

%%% exists_window
\begin{scriptdef}{exists\_window}
\sparam{window\_name}{\tstring}{Name eines Anzeigefensters}
\sresult{\tboolean}{\toktrue, falls das Anzeigefenster existiert, \tokfalse
sonst}
\saction{Ermittelt, ob in GIANT ein Anzeigefenster mit Name window\_name
existiert.}
\end{scriptdef}

%%% get_window_content
\begin{scriptdef}{get\_window\_content}
\sparam{window\_name}{\tstring}{Name eines Anzeigefensters}
\sresult{\tobjectset}{Alle Fenster-Knoten und Fenster-Kanten des
Anzeigefensters}
\saction{Ermittelt den Teilgraphen des IML-Graphen der in dem Anzeigefenster
window\_name enthalten ist.
Es ist ein Laufzeitfehler, falls kein Anzeigefenster mit Namen window\_name
existiert.}
\end{scriptdef}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Aktionen auf der GUI}

%%% create_window
\begin{scriptdef}{create\_window}
\sparam{window\_name}{\tstring}{Der Name des zu erzeugenden Anzeigefensters.}
\sresult{\tboolean}{\toktrue falls das Anzeigefenster erzeugt wurde,
\tokfalse sonst.}
\saction{Erzeugt ein neues Anzeigefenster mit Name window\_name in GIANT, falls
ein solches noch nicht existiert. Öffnet das neue Anzeigefenster.}
\end{scriptdef}

%%% insert_into_window
\begin{scriptdef}{insert\_into\_window}
\sparam{window\_name}{\tstring}{Name eines Anzeigefensters}
\sparam{selection\_name}{\tstring}{Name einer Selektion}
\sparam{add\_content}{\tobjectset}{Einzufügender IML-Teilgraph}
\sparam{layout\_algo}{\tstring}{Name eines Layoutalgorithmus}
\sparam{parameters}{\tstring}{Parameter für den Layoutalgorithmus}
\sresult{\toknull}{}
\saction{Bildet die größte Teilmenge $G$ von add\_content, so dass jede
IML-Kante in $G$ zu genau zwei IML-Knoten in $G$ inzident ist und $G$ alle
IML-Knoten aus add\_content enthält.
Wendet den Layoutalgorithmus layout\_algo auf content an. Übergibt
parameters als Parameter an den Layoutalgorithmus. Fügt das Resultat
in das Anzeigefenster mit Name window\_name ein. Verändert außerdem
die Selektion mit name selection\_name in dem Anzeigefenster
window\_name, so dass diese Selektion genau add\_content enthält und
sonst nichts. Falls die Selektion noch nicht existierte, so wird sie erzeugt.

Es ist ein Laufzeitfehler, falls layout\_algo kein Name eine bekannten
Layoutalgorithmus ist.
Es ist ein Laufzeitfehler, falls parameters kein korrekter
Parameterstring für den Layoutalgorithmus layout\_algo ist.
Es ist ein Laufzeitfehler, falls kein Anzeigefenster mit Namen window\_name
existiert.}
\end{scriptdef}

%%% remove_from_window
\begin{scriptdef}{remove\_from\_window}
\sparam{window\_name}{\tstring}{Name eines Anzeigefensters}
\sparam{remove\_content}{\tobjectset}{Zu entfernende IML-Knoten und IML-Kanten}
\sresult{\toknull}{}
\saction{Entfernt alle diejenigen IML-Knoten und IML-Kanten, die sowohl
in remove\_content als auch in dem Anzeigefenster mit mit Name window\_name
enthalten sind aus dem Anzeigefenster. Zusätzlich werden alle Fenster-Kanten
aus dem Anzeigefenster entfernt, deren Start- oder Zielknoten im Fenster
nicht mehr enthalten ist.

Es ist ein Laufzeitfehler, falls kein Anzeigefenster mit Namen window\_name
existiert.}
\end{scriptdef}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Häufig verwendete Scripts}
\label{standard}

Die hier definierten Scripts bilden eine Umgebung, die das Schreiben von
benutzerdefinierten Scripts vereinfachen soll. Jedes hier vorgestellte Script
ist redundant.

Diese Scripts werden durch den Ausdruck in der Datei \gq{standard.gsl}
definiert.

\begin{scriptdef}{not}
\sparam{a}{\tboolean oder \tscriptreference}{boolscher Wert oder
Aktivierungsinformation für ein parameterloses Script, das den boolschen
Wert zum Ergebnis hat}
\sresult{\tboolean}{Negation von a}
\saction{Logische Negation}
\end{scriptdef}

\begin{scriptdef}{and\_then}
\sparam{a}{\tboolean oder \tscriptreference}{boolscher Wert oder
Aktivierungsinformation für ein parameterloses Script, dass den boolschen
Wert zum Ergebnis hat}
\sparam{b}{nur \tscriptreference}{Aktivierungsinformation für ein
parameterloses Script, das den boolschen Wert zum Ergebnis hat}
\sresult{\tboolean}{Logische Konjunktion von a und b}
\saction{Berechnet die logische Konjunktion. Falls a eine
Aktivierungsinformation ist, so wird das zugehörige Script aktiviert und
liefert als Ergebnis $v$. Andernfalls ist $v =$ a.
Falls $v$ nicht erfüllt ist, so wird das durch b referenzierte Script nicht
aktiviert. Andernfalls wird es ausgewertet und die Konjunktion berechnet.}
\end{scriptdef}

\begin{scriptdef}{and}
\sparam{a}{\tboolean oder \tscriptreference}{boolscher Wert oder
Aktivierungsinformation für ein parameterloses Script, das den boolschen
Wert zum Ergebnis hat}
\sparam{b}{\tboolean oder \tscriptreference}{boolscher Wert oder
Aktivierungsinformation für ein parameterloses Script, das den boolschen
Wert zum Ergebnis hat}
\sresult{\tboolean}{Logische Konjunktion von a und b}
\saction{Berechnet die logische Konjunktion. Falls Aktivierungsinformationen
übergeben wurden, so werden die zugehörigen Scripts auf jeden Fall aktiviert.
Falls a und b beides Aktivierungsinformationen sind, so wird zuerst a, dann
b aktiviert.}
\end{scriptdef}

\begin{scriptdef}{or\_else}
\sparam{a}{\tboolean oder \tscriptreference}{boolscher Wert oder
Aktivierungsinformation für ein parameterloses Script, das den boolschen
Wert zum Ergebnis hat}
\sparam{b}{nur \tscriptreference}{Aktivierungsinformation für ein
parameterloses Script, das den boolschen Wert zum Ergebnis hat}
\sresult{\tboolean}{Logische Disjunktion von a und b}
\saction{Berechnet die logische Diskunktion. Falls a eine
Aktivierungsinformation ist, so wird das zugehörige Script aktiviert und
liefert als Ergebnis $v$. Andernfalls ist $v =$ a.
Falls $v$ erfüllt ist, so wird das durch b referenzierte Script nicht
aktiviert. Andernfalls wird es ausgewertet und die Disjunktion berechnet.}
\end{scriptdef}

\begin{scriptdef}{or}
\sparam{a}{\tboolean oder \tscriptreference}{boolscher Wert oder
Aktivierungsinformation für ein parameterloses Script, das den boolschen
Wert zum Ergebnis hat.}
\sparam{b}{\tboolean oder \tscriptreference}{boolscher Wert oder
Aktivierungsinformation für ein parameterloses Script, das den boolschen
Wert zum Ergebnis hat.}
\sresult{\tboolean}{Logische Disjunktion von a und b}
\saction{Berechnet die logische Disjunktion. Falls Aktivierungsinformationen
übergeben wurden, so werden die zugehörigen Scripts auf jeden Fall aktiviert.
Falls a und b beides Aktivierungsinformationen sind, so wird zuerst a, dann
b aktiviert.}
\end{scriptdef}

\begin{scriptdef}{while}
\sparam{b}{\tscriptreference}{Aktivierungsinformation für ein
parameterloses Script das als Ergebnis einen Wert vom Typ \tboolean hat.}
\sparam{c}{\tscriptreference}{Aktivierungsinformation für ein parameterloses
Script.}
\sresult{}{\toknull}
\saction{Wertet wiederholt abwechselnd zuerst b und dann c aus. Stoppt,
sobald b das Ergebnis \tokfalse hat.}
\end{scriptdef}

\begin{scriptdef}{repeat}
\sparam{c}{\tscriptreference}{Aktivierungsinformation für ein parameterloses
Script.}
\sparam{until}{\tscriptreference}{Aktivierungsinformation für ein
parameterloses Script das als Ergebnis einen Wert vom Typ \tboolean hat.}
\sresult{}{\toknull}
\saction{Wertet c einmal aus. Wertet dann wiederholt abwechselnd zuerst
until und dann c aus. Stoppt, sobald until das Ergebnis \tokfalse hat.}
\end{scriptdef}

\begin{scriptdef}{union}
\sparam{A}{\tnodeset oder \tedgeset}{}
\sparam{B}{der selbe Typ wie A}{}
\sresult{der selbe Typ wie A}{}
\saction{Berechnet die Mengenvereinigung von A und B.}
\end{scriptdef}

\begin{scriptdef}{intersection}
\sparam{A}{\tnodeset oder \tedgeset}{}
\sparam{B}{der selbe Typ wie A}{}
\sresult{der selbe Typ wie A}{}
\saction{Berechnet die Schnittmenge von A und B.}
\end{scriptdef}

\begin{scriptdef}{difference}
\sparam{A}{\tnodeset oder \tedgeset}{}
\sparam{B}{der selbe Typ wie A}{}
\sresult{der selbe Typ wie A}{}
\saction{Berechnet die Mengendifferenz A - B.}
\end{scriptdef}

\begin{scriptdef}{select\_nodes}
\sparam{from}{\tnodeset}{Gundmenge}
\sparam{node\_predicate}{\tscriptreference}{Aktivierungsinformation für ein
Script, das als einzigen Parameter einen Wert vom Typ \tnodeid nimmt und
ein Ergebnis vom Typ \tboolean hat}
\sresult{\tnodeset}{}
\saction{Ermittelt die größte Teilmenge von from, so dass alle IML-Knoten in
dieser Teilmenge das node\_predicate erfüllen.}
\end{scriptdef}

\begin{scriptdef}{build\_nodes}
\sparam{edge\_set}{\tedgeset}{Kantenmenge}
\sparam{node\_predicate}{\tscriptreference}{Aktivierungsinformation für ein
Script, das als einzigen Parameter einen Wert vom Typ \tnodeid nimmt und
ein Ergebnis vom Typ \tboolean hat}
\sresult{\tnodeset}{}
\saction{Ermittelt die Menge aller IML-Knoten, die zu einer Kante aus
edge\_set inzident sind und das node\_predicate erfüllen.}
\end{scriptdef}

\begin{scriptdef}{for\_each}
\sparam{set}{\tnodeset oder \tedgeset}{Grundmenge}
\sparam{action}{\tscriptreference}{Aktivierungsinformation für ein Script,
das genau einen Parameter vom Elementtyp der Grundmenge hat (Also \tnodeid
für \tnodeset bzw.\ \tedgeid für \tedgeset)}
\sresult{}{\toknull}
\saction{Iteriert über alle Elemente der Grundmenge und aktiviert action
je einmal für jedes Element. Übergibt das Element an action als einzigen
Parameter.}
\end{scriptdef}


\DeleteShortVerb{\°}

%==============================================================================
%
%  Index
%
\printindex

%==============================================================================
% 
% Anhang
%
\newpage
\appendix

\end{document}
